{{ if .IsHome }}
  <script>
    (function () {
      const section = document.querySelector('.contact-walkers');
      if (!section || document.getElementById('flow-contact')) {
        return;
      }

      if (!window.p5) {
        return;
      }

      const motionQuery = window.matchMedia && window.matchMedia('(prefers-reduced-motion: reduce)');
      if (motionQuery && motionQuery.matches) {
        return;
      }

      const container = document.createElement('div');
      container.id = 'flow-contact';
      container.setAttribute('aria-hidden', 'true');
      container.style.position = 'absolute';
      container.style.inset = '0';
      container.style.zIndex = '1';
      container.style.pointerEvents = 'none';
      section.prepend(container);

      if (getComputedStyle(section).position === 'static') {
        section.style.position = 'relative';
      }

      const walkerColor = '#5bc0eb';
      const baseBg =
        getComputedStyle(document.body).backgroundColor || 'rgb(248, 244, 238)';

      const sketch = (p) => {
        let particles = [];
        let bounds = { w: 1, h: 1 };
        let bgColor = null;
        let pointerListenerAttached = false;
        let lastPointer = null;
        let lastPointerTime = 0;
        let grid = [];
        let gridCols = 0;
        let gridRows = 0;

        const field = {
          noiseScale: 520,
          noiseStrength: 1.05,
          minSpeed: 0.35,
          maxSpeed: 1.2,
          minWeight: 1.1,
          maxWeight: 2.2,
          trailLength: 400,
        };

        const countFor = (width, height) => {
          const area = Math.max(1, width) * Math.max(1, height);
          const base = Math.round(area / 9000);
          return Math.max(140, Math.min(320, base));
        };

        const strokeField = {
          cellSize: 48,
          decay: 0.95,
          injectScale: 0.038,
          maxStrength: 6.5,
        };

        class Particle {
          constructor() {
            this.reset();
          }

          reset() {
            this.pos = p.createVector(p.random(bounds.w * 1.1), p.random(bounds.h));
            this.prev = this.pos.copy();
            this.speed = p.random(field.minSpeed, field.maxSpeed);
            this.weight = p.random(field.minWeight, field.maxWeight);
            this.stroke = p.color(walkerColor);
            this.stroke.setAlpha(40);
            this.history = [this.pos.copy()];
          }

          step() {
            const angle =
              p.noise(this.pos.x / field.noiseScale, this.pos.y / field.noiseScale, p.frameCount / field.noiseScale) *
              p.TWO_PI *
              field.noiseStrength;
            let vx = Math.cos(angle);
            let vy = Math.sin(angle);
            if (grid.length) {
              const col = Math.max(0, Math.min(gridCols - 1, Math.floor(this.pos.x / strokeField.cellSize)));
              const row = Math.max(0, Math.min(gridRows - 1, Math.floor(this.pos.y / strokeField.cellSize)));
              const cell = grid[row * gridCols + col];
              if (cell) {
                vx += cell.x;
                vy += cell.y;
              }
            }
            const mag = Math.hypot(vx, vy) || 1;
            vx /= mag;
            vy /= mag;
            this.pos.x += vx * this.speed;
            this.pos.y += vy * this.speed;
            this.history.push(this.pos.copy());
            if (this.history.length > field.trailLength) {
              this.history.shift();
            }
          }

          draw() {
            if (this.history.length < 2) return;
            p.strokeWeight(this.weight);
            for (let i = 1; i < this.history.length; i += 1) {
              const prev = this.history[i - 1];
              const next = this.history[i];
              const alpha = (i / this.history.length) * 40;
              const color = p.color(this.stroke);
              color.setAlpha(alpha);
              p.stroke(color);
              p.line(prev.x, prev.y, next.x, next.y);
            }
          }

          wrap() {
            if (this.pos.x < 0 || this.pos.x > bounds.w || this.pos.y < 0 || this.pos.y > bounds.h) {
              this.reset();
            }
          }
        }

        const seedParticles = () => {
          particles = [];
          const count = countFor(bounds.w, bounds.h);
          for (let i = 0; i < count; i += 1) {
            particles.push(new Particle());
          }
        };

        const refreshBackground = () => {
          bgColor = p.color(baseBg);
          bgColor.setAlpha(255);
        };

        const updatePointer = (event) => {
          const rect = section.getBoundingClientRect();
          const touch = event.touches && event.touches[0];
          const clientX = touch ? touch.clientX : event.clientX;
          const clientY = touch ? touch.clientY : event.clientY;
          const x = clientX - rect.left;
          const y = clientY - rect.top;
          if (x < 0 || x > rect.width || y < 0 || y > rect.height) {
            lastPointer = null;
            return;
          }
          const now = p.millis();
          if (lastPointer) {
            const dt = Math.max(0.016, (now - lastPointerTime) / 1000);
            const dx = x - lastPointer.x;
            const dy = y - lastPointer.y;
            const speed = Math.hypot(dx, dy) / dt;
            const dirMag = Math.hypot(dx, dy) || 1;
            const dirX = dx / dirMag;
            const dirY = dy / dirMag;
            const strength = Math.min(strokeField.maxStrength, speed * strokeField.injectScale);
            const col = Math.max(0, Math.min(gridCols - 1, Math.floor(x / strokeField.cellSize)));
            const row = Math.max(0, Math.min(gridRows - 1, Math.floor(y / strokeField.cellSize)));
            const cell = grid[row * gridCols + col];
            if (cell) {
              cell.x += dirX * strength;
              cell.y += dirY * strength;
              const cellMag = Math.hypot(cell.x, cell.y);
              if (cellMag > strokeField.maxStrength) {
                cell.x = (cell.x / cellMag) * strokeField.maxStrength;
                cell.y = (cell.y / cellMag) * strokeField.maxStrength;
              }
            }
          }
          lastPointer = { x, y };
          lastPointerTime = now;
        };

        const resize = (width, height) => {
          const safeHeight = Math.min(height || 1, 1200);
          bounds = {
            w: Math.max(1, Math.floor(width)),
            h: Math.max(1, Math.floor(safeHeight)),
          };
          p.resizeCanvas(bounds.w, bounds.h);
          gridCols = Math.max(1, Math.ceil(bounds.w / strokeField.cellSize));
          gridRows = Math.max(1, Math.ceil(bounds.h / strokeField.cellSize));
          grid = new Array(gridCols * gridRows).fill(null).map(() => ({ x: 0, y: 0 }));
          seedParticles();
        };

        p.setup = () => {
          const rect = section.getBoundingClientRect();
          const safeHeight = Math.min(rect.height || 1, 1200);
          bounds = {
            w: Math.max(1, Math.floor(rect.width)),
            h: Math.max(1, Math.floor(safeHeight)),
          };
          const canvas = p.createCanvas(bounds.w, bounds.h);
          canvas.parent(container);
          p.pixelDensity(1);
          p.frameRate(24);
          refreshBackground();
          p.background(bgColor);
          gridCols = Math.max(1, Math.ceil(bounds.w / strokeField.cellSize));
          gridRows = Math.max(1, Math.ceil(bounds.h / strokeField.cellSize));
          grid = new Array(gridCols * gridRows).fill(null).map(() => ({ x: 0, y: 0 }));
          seedParticles();

          if (!pointerListenerAttached) {
            window.addEventListener('mousemove', updatePointer, { passive: true });
            window.addEventListener('touchmove', updatePointer, { passive: true });
            window.addEventListener('touchstart', updatePointer, { passive: true });
            pointerListenerAttached = true;
          }
        };

        p.draw = () => {
          if (!bgColor) {
            refreshBackground();
          }
          p.background(bgColor);
          if (grid.length) {
            for (const cell of grid) {
              cell.x *= strokeField.decay;
              cell.y *= strokeField.decay;
              if (Math.abs(cell.x) < 0.0001) cell.x = 0;
              if (Math.abs(cell.y) < 0.0001) cell.y = 0;
            }
          }
          for (const particle of particles) {
            particle.step();
            particle.draw();
            particle.wrap();
          }
        };

        if (window.ResizeObserver) {
          const observer = new ResizeObserver((entries) => {
            if (!entries.length) return;
            const { width, height } = entries[0].contentRect;
            resize(width, height);
          });
          observer.observe(section);
        } else {
          window.addEventListener('resize', () => {
            const rect = section.getBoundingClientRect();
            resize(rect.width, rect.height);
          });
        }
      };

      new window.p5(sketch, container);
    })();
  </script>
{{ end }}
